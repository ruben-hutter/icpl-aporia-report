\section{Implementation}

\subsection{Overview}
\lipsum[1]

\begin{figure}[h]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		bop ::= + // - // * // / // \%;;
		pred ::= true // false // bool\_var;;
		bool\_exp ::= pred // (bool\_exp) // !bool\_exp
		| bool\_exp \&\& bool\_exp
		| bool\_exp cmp bool\_exp;;
		num\_exp ::= number // num\_var // (num\_exp) // -num\_exp
		| num\_exp bop num\_exp;;
		inst ::= print("string",bool\_exp) // bool\_exp
		| print("string", num\_exp) // num\_exp
		| bool\_var $=$ bool\_exp
		| num\_var $=$ num\_exp;;
		stmt ::= (\$label)? // pred $\colon$ inst;;
		declar ::= bool bool\_var$^+$ // int num\_var$^+$ // int float\_var$^+$;;
		$L_{cfi}$ ::= declar$^*$ stmt$^*$
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{cfi}$}
	\label{lcfi}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		exp ::= int // input\_int() // -exp
		| exp + exp // exp - exp
		| (exp) // var
		| True // False // exp and exp
		| exp or exp // not exp // exp cmp exp
		| exp if exp else exp;;
		stmt ::= print(exp) // exp // var = exp
		| if exp $\colon$ stmt$^+$ else $\colon$ stmt$^+$;;
		$L_{if}$ ::= stmt$^+$
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{if}$}
	\label{lif}
\end{figure}

\subsection{First pass: Remove complex operands ($L_{if}^{sc}$)}

\begin{figure}[h!]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		atm ::= True // False // var;;
		exp ::= int  // -exp // exp + exp 
		| exp - exp // (exp)
		| exp and exp // exp or exp 
		| not exp // exp cmp exp // atm;;
		stmt ::= print(exp) // exp // var = exp
		| if atm$\colon$ stmt$^+$;;
		$L_{sc}$ ::= stmt$^+$;;
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{sc}$}
	\label{bnf:sc}
\end{figure}

The first pass of the compiler lays an important foundation for each of following passes. It simplifies the input program by performing the following four transformations:

\subsubsection{Remove top level expressions that have no effect:}
Any top level expression like a simple addition \texttt{1 + 2} or a boolean operation \texttt{true and false} is removed from the program.
This goes against the principle of Aporia, which wants to make the original program as complicated as possible but was necessary to simplify the implementation of the compiler.

\subsubsection{Create variables for complex conditions:}
The predicates in the statements of $L_{cfi}$ cannot be complex boolean expressions but only variables or the two boolean constants \texttt{true} and \texttt{false}.
Hence, if the compiler encounters a complex boolean expression as the condition of an if-statement, it creates a new boolean variable and assigns the complex expression to it. 
The compiler then replaces the complex expression with the new variable as the condition.

\subsubsection{Remove else branches:}
Each statement in $L_{cfi}$ can only have one branch, so the compiler must remove the else branch of if-statements.
In order to complete this step, the compiler assigns the negated condition of the if-statement to a new boolean variable.
This variable is then used as the condition of a second if-statement, which contains the else branch of the original statement as its body.

\subsubsection{Turn if-expressions into if-statements:}
$L_{cfi}$ does not support if-expressions, so the compiler must transform them into if-statements with empty else branches. This is done in a similar way as in the exercise part of the seminar.
First, the condition is made atomic and the its negation assigned to a new variable as in the previous steps.
Then, two if-statements are created, one for the body and one for the orelse branch of the original if-expression.
Since top level expressions are ignored, the only context that if-expressions can occur in are variable assignments either as an original statement or to atomify a complex condition.
The result of the if-expression must thus always be assigned to the given variable name as the last statement of the new body in the new if-statement.
If the expression is part of a top level assign, the variable name is given by the original program. Else, a new variable name is generated.

\begin{figure}[h]
	\centering
	\lstinputlisting[language=python]{reportContent/code_examples/1_pres_example.py}
	\caption{Result after the first pass of example program}
	\label{code:sc}
\end{figure}


\subsection{Second pass: Flatten and Make everything an if ($L_{if}^{flat}$)}
\begin{figure}[h!]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		atm ::= True // False // var;;
		exp ::= int  // -exp // exp + exp 
		| exp - exp // (exp)
		| exp and exp // exp or exp 
		| not exp // exp cmp exp // atm;;
		stmt ::= print(exp) // exp // var = exp;;
		if\_stmt ::= if atm$\colon$ stmt;;
		$L_{flat}$ ::= if\_stmt$^+$;;
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{flat}$}
	\label{bnf:flat}
\end{figure}

The goal of this pass is to eliminate nested \texttt{if} statements, ensuring that all statements are wrapped in top-level \texttt{if} statements in the resulting intermediary language. We call this language $L_{flat}$, which inherits from $L_{sc}$ but restricts all \texttt{if} statements to be top-level only, as described by the BNF in Figure~\ref{bnf:flat}. Consequently, each \texttt{if} statement body now contains exactly one statement, which can not be an \texttt{if} statement, thereby preventing any form of nesting.

The compiler takes an $L_{sc}$ AST as input and produces an $L_{flat}$ AST. Applying this pass to the sample code shown above yields the flattened version in Figure~\ref{code:flat}. Statements that were not originally inside any \texttt{if} are wrapped in an \texttt{if True} statement, while statements that were nested in an \texttt{if} block are guarded by newly introduced boolean variables.

\begin{figure}[h!]
	\lstinputlisting[language=python]{reportContent/code_examples/2_pres_example.py}
	\caption{$L_{flat}$ example code}
	\label{code:flat}
\end{figure}

When the compiler encounters an \texttt{if} statement nested within another \texttt{if}, it generates a temporary boolean variable holding the conjunction of the outer and inner conditions. The statements in the nested \texttt{if} block are then wrapped in a new \texttt{if} whose predicate is this temporary variable. By repeating this process, we flatten all nested \texttt{if} statements without changing the original program's logical flow.

\subsection{Third pass: Select instructions ($L_{cif}$)}

\lipsum[2-3]
