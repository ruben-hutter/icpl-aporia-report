\section{Implementation}

\subsection{Overview}
\lipsum[1]

\begin{figure}[h]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		bop ::= + // - // * // / // \%;;
		pred ::= true // false // bool\_var;;
		bool\_exp ::= pred // (bool\_exp) // !bool\_exp
		| bool\_exp \&\& bool\_exp
		| bool\_exp cmp bool\_exp;;
		num\_exp ::= number // num\_var // (num\_exp) // -num\_exp
		| num\_exp bop num\_exp;;
		inst ::= print("string",bool\_exp) // bool\_exp
		| print("string", num\_exp) // num\_exp
		| bool\_var $=$ bool\_exp
		| num\_var $=$ num\_exp;;
		stmt ::= (\$label)? // pred $\colon$ inst;;
		declar ::= bool bool\_var$^+$ // int num\_var$^+$ // int float\_var$^+$;;
		$L_{cfi}$ ::= declar$^*$ stmt$^*$
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{cfi}$}
	\label{lcfi}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		exp ::= int // input\_int() // -exp
		| exp + exp // exp - exp
		| (exp) // var
		| True // False // exp and exp
		| exp or exp // not exp // exp cmp exp
		| exp if exp else exp;;
		stmt ::= print(exp) // exp // var = exp
		| if exp $\colon$ stmt$^+$ else $\colon$ stmt$^+$;;
		$L_{if}$ ::= stmt$^+$
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{if}$}
	\label{lif}
\end{figure}

\subsection{First pass: Remove complex operands ($L_{if}^{sc}$)}

\begin{figure}[h!]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		atm ::= True // False // var;;
		exp ::= int  // -exp // exp + exp 
		| exp - exp // (exp)
		| exp and exp // exp or exp 
		| not exp // exp cmp exp // atm;;
		stmt ::= print(exp) // exp // var = exp
		| if atm$\colon$ stmt$^+$;;
		$L_{sc}$ ::= stmt$^+$;;
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{sc}$}
	\label{sc}
\end{figure}

\lipsum[2-3]
\subsection{Second pass: Flatten and Make everything an if ($L_{if}^{flat}$)}
\begin{figure}[h!]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		atm ::= True // False // var;;
		exp ::= int  // -exp // exp + exp 
		| exp - exp // (exp)
		| exp and exp // exp or exp 
		| not exp // exp cmp exp // atm;;
		stmt ::= print(exp) // exp // var = exp;;
		if\_stmt ::= if atm$\colon$ stmt;;
		$L_{flat}$ ::= if\_stmt$^+$;;
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{flat}$}
	\label{bnf:flat}
\end{figure}

The goal of this pass is to eliminate nested \texttt{if} statements, ensuring that all statements are wrapped in top-level \texttt{if} statements in the resulting intermediary language. We call this language $L_{flat}$, which inherits from $L_{sc}$ but restricts all \texttt{if} statements to be top-level only, as described by the BNF in Figure~\ref{bnf:flat}. Consequently, each \texttt{if} statement body now contains exactly one statement, which can not be an \texttt{if} statement, thereby preventing any form of nesting.

The compiler takes an $L_{sc}$ AST as input and produces an $L_{flat}$ AST. Applying this pass to the sample code shown above yields the flattened version in Figure~\ref{code:flat}. Statements that were not originally inside any \texttt{if} are wrapped in an \texttt{if True} statement, while statements that were nested in an \texttt{if} block are guarded by newly introduced boolean variables.

\begin{figure}[h!]
	\lstinputlisting[language=python]{reportContent/code_examples/2_pres_example.py}
	\caption{$L_{flat}$ example code}
	\label{code:flat}
\end{figure}

When the compiler encounters an \texttt{if} statement nested within another \texttt{if}, it generates a temporary boolean variable holding the conjunction of the outer and inner conditions. The statements in the nested \texttt{if} block are then wrapped in a new \texttt{if} whose predicate is this temporary variable. By repeating this process, we flatten all nested \texttt{if} statements without changing the original program's logical flow.

\subsection{Third pass: Select instructions ($L_{cif}$)}

\lipsum[2-3]
