\section{Implementation}

\subsection{Overview}
\lipsum[1]

\begin{figure}[h]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		bop ::= + // - // * // / // \%;;
		pred ::= true // false // bool\_var;;
		bool\_exp ::= pred // (bool\_exp) // !bool\_exp
		| bool\_exp \&\& bool\_exp
		| bool\_exp cmp bool\_exp;;
		num\_exp ::= number // num\_var // (num\_exp) // -num\_exp
		| num\_exp bop num\_exp;;
		inst ::= print("string",bool\_exp) // bool\_exp
		| print("string", num\_exp) // num\_exp
		| bool\_var $=$ bool\_exp
		| num\_var $=$ num\_exp;;
		stmt ::= (\$label)? // pred $\colon$ inst;;
		declar ::= bool bool\_var$^+$ // int num\_var$^+$ // int float\_var$^+$;;
		$L_{cfi}$ ::= declar$^*$ stmt$^*$
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{cfi}$}
	\label{lcfi}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		exp ::= int // input\_int() // -exp
		| exp + exp // exp - exp
		| (exp) // var
		| True // False // exp and exp
		| exp or exp // not exp // exp cmp exp
		| exp if exp else exp;;
		stmt ::= print(exp) // exp // var = exp
		| if exp $\colon$ stmt$^+$ else $\colon$ stmt$^+$;;
		$L_{if}$ ::= stmt$^+$
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{if}$}
	\label{lif}
\end{figure}

\subsection{First pass: Remove complex operands ($L_{if}^{sc}$)}

\begin{figure}[h!]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		atm ::= True // False // var;;
		exp ::= int  // -exp // exp + exp 
		| exp - exp // (exp)
		| exp and exp // exp or exp 
		| not exp // exp cmp exp // atm;;
		stmt ::= print(exp) // exp // var = exp
		| if atm$\colon$ stmt$^+$;;
		$L_{sc}$ ::= stmt$^+$;;
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{sc}$}
	\label{bnf:sc}
\end{figure}

The first pass of the compiler lays an important foundation for each of following passes. It simplifies the input program by performing the following four transformations:

\subsubsection{Remove top level expressions that have no effect:}
Any top level expression like a simple addition \texttt{1 + 2} or a boolean operation \texttt{true and false} is removed from the program.
This goes against the principle of Aporia, which wants to make the original program as complicated as possible but was necessary to simplify the implementation of the compiler.

\subsubsection{Create variables for complex conditions:}
The predicates in the statements of $L_{cfi}$ cannot be complex boolean expressions but only variables or the two boolean constants \texttt{true} and \texttt{false}.
Hence, if the compiler encounters a complex boolean expression as the condition of an if-statement, it creates a new boolean variable and assigns the complex expression to it. 
The compiler then replaces the complex expression with the new variable as the condition.

\subsubsection{Remove else branches:}
Each statement in $L_{cfi}$ can only have one branch, so the compiler must remove the else branch of if-statements.
In order to complete this step, the compiler assigns the negated condition of the if-statement to a new boolean variable.
This variable is then used as the condition of a second if-statement, which contains the else branch of the original statement as its body.

\subsubsection{Turn if-expressions into if-statements:}
$L_{cfi}$ does not support if-expressions, so the compiler must transform them into if-statements with empty else branches. This is done in a similar way as in the exercise part of the seminar.
First, the condition is made atomic and the its negation assigned to a new variable as in the previous steps.
Then, two if-statements are created, one for the body and one for the orelse branch of the original if-expression.
Since top level expressions are ignored, the only context that if-expressions can occur in are variable assignments either as an original statement or to atomify a complex condition.
The result of the if-expression must thus always be assigned to the given variable name as the last statement of the new body in the new if-statement.
If the expression is part of a top level assign, the variable name is given by the original program. Else, a new variable name is generated.

\begin{figure}[h]
	\centering
	\lstinputlisting[language=python]{reportContent/code_examples/1_pres_example.py}
	\caption{Result after the first pass of example program}
	\label{code:sc}
\end{figure}


\subsection{Second pass: Flatten and Make everything an if ($L_{if}^{flat}$)}
\begin{figure}[h!]
	\centering
	\begin{bnf}[row{-} = {bg = gray9}]
		cmp ::= != // == // < // <= // > // >=;;
		atm ::= True // False // var;;
		exp ::= int  // -exp // exp + exp 
		| exp - exp // (exp)
		| exp and exp // exp or exp 
		| not exp // exp cmp exp // atm;;
		stmt ::= print(exp) // exp // var = exp;;
		if\_stmt ::= if atm$\colon$ stmt;;
		$L_{flat}$ ::= if\_stmt$^+$;;
	\end{bnf}
	\caption{Backus Naur Form Grammar of $L_{flat}$}
	\label{bnf:flat}
\end{figure}

The goal of this pass is to eliminate nested \texttt{if} statements, ensuring that all statements are wrapped in top-level \texttt{if} statements in the resulting intermediary language. We call this language $L_{flat}$, which inherits from $L_{sc}$ but restricts all \texttt{if} statements to be top-level only, as described by the BNF in Figure~\ref{bnf:flat}. Consequently, each \texttt{if} statement body now contains exactly one statement, which can not be an \texttt{if} statement, thereby preventing any form of nesting. The compiler takes an $L_{sc}$ AST as input and produces an $L_{flat}$ AST. Applying this pass to the sample code shown in Figure \ref{code:sc} yields the flattened version in Figure~\ref{code:flat}. The compiler of this pass makes the following transformations:

\subsubsection{Wrap statements not originally in an if-block with if True:} Any statement at the top level (i.e., not in an \texttt{if}) is enclosed in an \texttt{if True} block. This step ensures that every statement in the resulting code is preceded by \texttt{if}. We can see that lines 1-2 in Figure \ref{code:sc} transform to lines 3-4 in Figure \ref{code:flat}.

\subsubsection{Flatten nested if statements:}
When the compiler encounters an \texttt{if} statement nested within another \texttt{if}, it creates a temporary boolean variable that stores the conjunction of the outer and inner conditions. In Figure~\ref{code:sc}, for example, the nested \texttt{if} on line 7 is transformed into the conjunction on line 12 in Figure~\ref{code:flat}. The statements within the nested \texttt{if} block are then placed in a new \texttt{if} statement whose predicate is this temporary variable, as shown on lines 13–14 in Figure~\ref{code:flat}. By applying this process repeatedly, the compiler flattens all nested \texttt{if} statements without altering the program’s logical flow.

\begin{figure}[h!]
	\lstinputlisting[language=python]{reportContent/code_examples/2_pres_example.py}
	\caption{$L_{flat}$ example code}
	\label{code:flat}
\end{figure}


\subsection{Third pass: Select instructions ($L_{cif}$)}

\lipsum[2-3]
