\section{Technical Background}

\subsection{Program Obfuscation and Its Challenges}
Program obfuscation is the process of transforming a program into a functionally equivalent version that is difficult to analyze or reverse-engineer. It is widely used for \textit{software protection, digital watermarking, and cryptographic applications}, such as secure multiparty computation and homomorphic encryption~\cite{ajorian2024aporia}. 

Traditional obfuscation techniques rely on ad hoc transformations like control flow flattening, junk code insertion, or opaque predicates. However, these methods often fail against modern deobfuscation tools that leverage symbolic execution and AI-assisted static analysis~\cite{ajorian2024aporia}. 

\subsection{Aporia: Instruction Decorrelation as an Obfuscation Strategy}
Aporia introduces instruction decorrelation, a technique that breaks the one-to-one mapping between source and compiled instructions. Unlike traditional obfuscation, decorrelation rearranges, delays, and duplicates instructions in a way that depends on runtime execution states~\cite{ajorian2024aporia}. 

This is achieved through two key mechanisms:
\begin{itemize}
    \item \textbf{Randomized Scheduling}: Instructions are not executed in their original order, forcing an adversary to reconstruct execution flow dynamically.
    \item \textbf{Context-Dependent Execution}: Execution conditions are based on hidden states, preventing static analysis.
\end{itemize}

\subsection{Security Model and Side-Channel Resistance}
Aporia’s security model assumes an \textit{adversary capable of both static and dynamic analysis}. However, unlike most obfuscation methods, instruction decorrelation also offers protection against speculative execution attacks (e.g., Spectre, Meltdown) by eliminating direct data dependencies~\cite{ajorian2024aporia}. 

Additionally, the system introduces phantom instructions; instructions that appear valid to an attacker but do not contribute to actual program execution. This makes symbolic execution impractical.

\subsection{The $L_{cfi}$ Language and Its Role in Obfuscation}
Lcfi (the target language of our compiler) is specifically designed to support instruction decorrelation. It employs:
\begin{itemize}
    \item \textbf{Predicate-based execution}, where each instruction is executed only if a dynamic condition holds.
    \item \textbf{Phantom instructions}, which introduce noise in the control flow to mislead attackers.
    \item \textbf{Delayed branching}, which defers the resolution of execution paths, making control flow reconstruction NP-hard~\cite{ajorian2024aporia}.
\end{itemize}

\subsection{Relation to Our Project}
Our project builds upon Aporia’s work by designing a compiler from $L_{if}$ to $L_{cfi}$, enabling automatic program transformation for obfuscation. The compiler translates a subset of Python ($L_{if}$) into $L_{cfi}$ through multiple intermediate representations, enforcing instruction decorrelation at various stages.

By leveraging Aporia’s randomized scheduling, context-aware execution, and phantom instructions, our compiler provides a practical tool for obfuscation that remains resilient against modern reverse-engineering techniques.

