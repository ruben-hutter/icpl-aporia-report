\section{Technical Background}

\subsection{Program Obfuscation and Its Challenges}
Program obfuscation is the process of transforming a program into a functionally equivalent version that is difficult to analyze or reverse-engineer. It is widely used for \textit{software protection, digital watermarking, and cryptographic applications}, such as secure multiparty computation and homomorphic encryption~\cite{ajorian2024aporia}. 

Traditional obfuscation techniques rely on ad hoc transformations like control flow flattening, junk code insertion, or opaque predicates. However, these methods often fail against modern deobfuscation tools that leverage symbolic execution and AI-assisted static analysis~\cite{ajorian2024aporia}. 

\subsection{Aporia: Instruction Decorrelation as an Obfuscation Strategy}
Aporia introduces instruction decorrelation, a technique that breaks the one-to-one mapping between source and compiled instructions. Unlike traditional obfuscation, decorrelation rearranges, delays, and duplicates instructions in a way that depends on runtime execution states~\cite{ajorian2024aporia}. 

This is achieved through two key mechanisms:
\begin{itemize}
    \item \textbf{Randomized Ordering}: Instructions are not executed in their original order, forcing an adversary to reconstruct execution flow dynamically.
    \item \textbf{Context-Dependent Execution}: Execution conditions are based on hidden states, preventing static analysis.
\end{itemize}

\subsection{The $L_{cfi}$ Language and Its Role in Obfuscation}
$L_{cfi}$ (the input language for Aporia) is specifically designed to support instruction decorrelation. It employs:
\begin{itemize}
    \item \textbf{Predicate-based execution}, where each instruction is executed only if a dynamic condition holds, making control flow reconstruction difficult.
\end{itemize}

While $L_{cfi}$ facilitates instruction decorrelation, its design constraints make it challenging to write directly. Developers must handle explicit predicates and low-level constructs, which significantly differ from high-level programming languages like Python.

\subsection{Relation to Our Project}
The goal of our project is to create the missing "bridge" between Python and the Aporia framework. Writing code directly in $L_{cfi}$ is impractical due to its low-level nature and strict requirements. Our compiler translates programs written in a subset of Python ($L_{if}$) into $L_{cfi}$. 

This transformation allows developers to:
\begin{itemize}
    \item Write secure code in a familiar, high-level syntax.
    \item Leverage Aporiaâ€™s obfuscation techniques without directly interacting with $L_{cfi}$.
\end{itemize}

By bridging this gap, our project streamlines the workflow for developers, enabling them to write Python-like programs and automatically obtain the obfuscation benefits provided by Aporia.

